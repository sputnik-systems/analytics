/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/jupyter-for-obsidian.ts
var jupyter_for_obsidian_exports = {};
__export(jupyter_for_obsidian_exports, {
  default: () => JupyterForObsidian
});
module.exports = __toCommonJS(jupyter_for_obsidian_exports);
var import_obsidian15 = require("obsidian");

// src/features/create-notebooks/create-notebooks-settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_CREATE_NOTEBOOKS_SETTINGS = {
  displayFileRibbonIcon: true,
  displayFolderContextMenuItem: true,
  openCreatedFileMode: "current-tab" /* CURRENT_TAB */
};
function registerCreateNotebooksSettingsUI(tab) {
  tab.registerSetting({
    section: "Plugin customization" /* PLUGIN_CUSTOMIZATION */,
    display: (el, plugin) => {
      new import_obsidian.Setting(el).setName("Ribbon icon for new notebooks").setDesc(
        "Whether to display a ribbon icon that creates a blank Jupyter notebook when clicked."
      ).addToggle(
        (toggle) => toggle.setValue(plugin.settings.displayFileRibbonIcon).onChange((value) => {
          plugin.settings.displayFileRibbonIcon = value;
        })
      );
    }
  });
  tab.registerSetting({
    section: "Plugin customization" /* PLUGIN_CUSTOMIZATION */,
    display: (el, plugin) => {
      new import_obsidian.Setting(el).setName("Folder context menu for new notebooks").setDesc(
        "If enabled, when you right-click on a folder, one of the actions will be to create a new Jupyter notebook in that folder."
      ).addToggle(
        (toggle) => toggle.setValue(plugin.settings.displayFolderContextMenuItem).onChange((value) => {
          plugin.settings.displayFolderContextMenuItem = value;
        })
      );
    }
  });
  tab.registerSetting({
    section: "Plugin customization" /* PLUGIN_CUSTOMIZATION */,
    display: (el, plugin) => {
      new import_obsidian.Setting(el).setName("Open created notebooks").setDesc(
        "Whether to open a notebook directly when it is created, and how to open it."
      ).addDropdown((dropdown) => {
        dropdown.addOption("dont-open" /* DONT */, "Do not open").addOption(
          "current-tab" /* CURRENT_TAB */,
          "Open in the current tab (default)"
        ).addOption("new-tab" /* NEW_TAB */, "Open in a new tab").addOption("split" /* SPLIT */, "Open in a new split tab").addOption("detached-window" /* WINDOW */, "Open in a detached window").setValue(plugin.settings.openCreatedFileMode).onChange((value) => {
          plugin.settings.openCreatedFileMode = value;
        });
      });
    }
  });
}

// src/services/jupyter-environment.ts
var import_child_process = require("child_process");

// node_modules/emittery/maps.js
var anyMap = /* @__PURE__ */ new WeakMap();
var eventsMap = /* @__PURE__ */ new WeakMap();
var producersMap = /* @__PURE__ */ new WeakMap();

// node_modules/emittery/index.js
var anyProducer = Symbol("anyProducer");
var resolvedPromise = Promise.resolve();
var listenerAdded = Symbol("listenerAdded");
var listenerRemoved = Symbol("listenerRemoved");
var canEmitMetaEvents = false;
var isGlobalDebugEnabled = false;
var isEventKeyType = (key) => typeof key === "string" || typeof key === "symbol" || typeof key === "number";
function assertEventName(eventName) {
  if (!isEventKeyType(eventName)) {
    throw new TypeError("`eventName` must be a string, symbol, or number");
  }
}
function assertListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError("listener must be a function");
  }
}
function getListeners(instance, eventName) {
  const events = eventsMap.get(instance);
  if (!events.has(eventName)) {
    return;
  }
  return events.get(eventName);
}
function getEventProducers(instance, eventName) {
  const key = isEventKeyType(eventName) ? eventName : anyProducer;
  const producers = producersMap.get(instance);
  if (!producers.has(key)) {
    return;
  }
  return producers.get(key);
}
function enqueueProducers(instance, eventName, eventData) {
  const producers = producersMap.get(instance);
  if (producers.has(eventName)) {
    for (const producer of producers.get(eventName)) {
      producer.enqueue(eventData);
    }
  }
  if (producers.has(anyProducer)) {
    const item = Promise.all([eventName, eventData]);
    for (const producer of producers.get(anyProducer)) {
      producer.enqueue(item);
    }
  }
}
function iterator(instance, eventNames) {
  eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
  let isFinished = false;
  let flush = () => {
  };
  let queue = [];
  const producer = {
    enqueue(item) {
      queue.push(item);
      flush();
    },
    finish() {
      isFinished = true;
      flush();
    }
  };
  for (const eventName of eventNames) {
    let set = getEventProducers(instance, eventName);
    if (!set) {
      set = /* @__PURE__ */ new Set();
      const producers = producersMap.get(instance);
      producers.set(eventName, set);
    }
    set.add(producer);
  }
  return {
    async next() {
      if (!queue) {
        return { done: true };
      }
      if (queue.length === 0) {
        if (isFinished) {
          queue = void 0;
          return this.next();
        }
        await new Promise((resolve) => {
          flush = resolve;
        });
        return this.next();
      }
      return {
        done: false,
        value: await queue.shift()
      };
    },
    async return(value) {
      queue = void 0;
      for (const eventName of eventNames) {
        const set = getEventProducers(instance, eventName);
        if (set) {
          set.delete(producer);
          if (set.size === 0) {
            const producers = producersMap.get(instance);
            producers.delete(eventName);
          }
        }
      }
      flush();
      return arguments.length > 0 ? { done: true, value: await value } : { done: true };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
function defaultMethodNamesOrAssert(methodNames) {
  if (methodNames === void 0) {
    return allEmitteryMethods;
  }
  if (!Array.isArray(methodNames)) {
    throw new TypeError("`methodNames` must be an array of strings");
  }
  for (const methodName of methodNames) {
    if (!allEmitteryMethods.includes(methodName)) {
      if (typeof methodName !== "string") {
        throw new TypeError("`methodNames` element must be a string");
      }
      throw new Error(`${methodName} is not Emittery method`);
    }
  }
  return methodNames;
}
var isMetaEvent = (eventName) => eventName === listenerAdded || eventName === listenerRemoved;
function emitMetaEvent(emitter, eventName, eventData) {
  if (!isMetaEvent(eventName)) {
    return;
  }
  try {
    canEmitMetaEvents = true;
    emitter.emit(eventName, eventData);
  } finally {
    canEmitMetaEvents = false;
  }
}
var Emittery = class {
  static mixin(emitteryPropertyName, methodNames) {
    methodNames = defaultMethodNamesOrAssert(methodNames);
    return (target) => {
      if (typeof target !== "function") {
        throw new TypeError("`target` must be function");
      }
      for (const methodName of methodNames) {
        if (target.prototype[methodName] !== void 0) {
          throw new Error(`The property \`${methodName}\` already exists on \`target\``);
        }
      }
      function getEmitteryProperty() {
        Object.defineProperty(this, emitteryPropertyName, {
          enumerable: false,
          value: new Emittery()
        });
        return this[emitteryPropertyName];
      }
      Object.defineProperty(target.prototype, emitteryPropertyName, {
        enumerable: false,
        get: getEmitteryProperty
      });
      const emitteryMethodCaller = (methodName) => function(...args) {
        return this[emitteryPropertyName][methodName](...args);
      };
      for (const methodName of methodNames) {
        Object.defineProperty(target.prototype, methodName, {
          enumerable: false,
          value: emitteryMethodCaller(methodName)
        });
      }
      return target;
    };
  }
  static get isDebugEnabled() {
    var _a, _b;
    if (typeof ((_a = globalThis.process) == null ? void 0 : _a.env) !== "object") {
      return isGlobalDebugEnabled;
    }
    const { env } = (_b = globalThis.process) != null ? _b : { env: {} };
    return env.DEBUG === "emittery" || env.DEBUG === "*" || isGlobalDebugEnabled;
  }
  static set isDebugEnabled(newValue) {
    isGlobalDebugEnabled = newValue;
  }
  constructor(options = {}) {
    var _a;
    anyMap.set(this, /* @__PURE__ */ new Set());
    eventsMap.set(this, /* @__PURE__ */ new Map());
    producersMap.set(this, /* @__PURE__ */ new Map());
    producersMap.get(this).set(anyProducer, /* @__PURE__ */ new Set());
    this.debug = (_a = options.debug) != null ? _a : {};
    if (this.debug.enabled === void 0) {
      this.debug.enabled = false;
    }
    if (!this.debug.logger) {
      this.debug.logger = (type, debugName, eventName, eventData) => {
        try {
          eventData = JSON.stringify(eventData);
        } catch (e) {
          eventData = `Object with the following keys failed to stringify: ${Object.keys(eventData).join(",")}`;
        }
        if (typeof eventName === "symbol" || typeof eventName === "number") {
          eventName = eventName.toString();
        }
        const currentTime = new Date();
        const logTime = `${currentTime.getHours()}:${currentTime.getMinutes()}:${currentTime.getSeconds()}.${currentTime.getMilliseconds()}`;
        console.log(`[${logTime}][emittery:${type}][${debugName}] Event Name: ${eventName}
	data: ${eventData}`);
      };
    }
  }
  logIfDebugEnabled(type, eventName, eventData) {
    if (Emittery.isDebugEnabled || this.debug.enabled) {
      this.debug.logger(type, this.debug.name, eventName, eventData);
    }
  }
  on(eventNames, listener, { signal } = {}) {
    assertListener(listener);
    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
    for (const eventName of eventNames) {
      assertEventName(eventName);
      let set = getListeners(this, eventName);
      if (!set) {
        set = /* @__PURE__ */ new Set();
        const events = eventsMap.get(this);
        events.set(eventName, set);
      }
      set.add(listener);
      this.logIfDebugEnabled("subscribe", eventName, void 0);
      if (!isMetaEvent(eventName)) {
        emitMetaEvent(this, listenerAdded, { eventName, listener });
      }
    }
    const off = () => {
      this.off(eventNames, listener);
      signal == null ? void 0 : signal.removeEventListener("abort", off);
    };
    signal == null ? void 0 : signal.addEventListener("abort", off, { once: true });
    if (signal == null ? void 0 : signal.aborted) {
      off();
    }
    return off;
  }
  off(eventNames, listener) {
    assertListener(listener);
    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
    for (const eventName of eventNames) {
      assertEventName(eventName);
      const set = getListeners(this, eventName);
      if (set) {
        set.delete(listener);
        if (set.size === 0) {
          const events = eventsMap.get(this);
          events.delete(eventName);
        }
      }
      this.logIfDebugEnabled("unsubscribe", eventName, void 0);
      if (!isMetaEvent(eventName)) {
        emitMetaEvent(this, listenerRemoved, { eventName, listener });
      }
    }
  }
  once(eventNames, predicate) {
    if (predicate !== void 0 && typeof predicate !== "function") {
      throw new TypeError("predicate must be a function");
    }
    let off_;
    const promise = new Promise((resolve) => {
      off_ = this.on(eventNames, (data) => {
        if (predicate && !predicate(data)) {
          return;
        }
        off_();
        resolve(data);
      });
    });
    promise.off = off_;
    return promise;
  }
  events(eventNames) {
    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
    for (const eventName of eventNames) {
      assertEventName(eventName);
    }
    return iterator(this, eventNames);
  }
  async emit(eventName, eventData) {
    var _a;
    assertEventName(eventName);
    if (isMetaEvent(eventName) && !canEmitMetaEvents) {
      throw new TypeError("`eventName` cannot be meta event `listenerAdded` or `listenerRemoved`");
    }
    this.logIfDebugEnabled("emit", eventName, eventData);
    enqueueProducers(this, eventName, eventData);
    const listeners = (_a = getListeners(this, eventName)) != null ? _a : /* @__PURE__ */ new Set();
    const anyListeners = anyMap.get(this);
    const staticListeners = [...listeners];
    const staticAnyListeners = isMetaEvent(eventName) ? [] : [...anyListeners];
    await resolvedPromise;
    await Promise.all([
      ...staticListeners.map(async (listener) => {
        if (listeners.has(listener)) {
          return listener(eventData);
        }
      }),
      ...staticAnyListeners.map(async (listener) => {
        if (anyListeners.has(listener)) {
          return listener(eventName, eventData);
        }
      })
    ]);
  }
  async emitSerial(eventName, eventData) {
    var _a;
    assertEventName(eventName);
    if (isMetaEvent(eventName) && !canEmitMetaEvents) {
      throw new TypeError("`eventName` cannot be meta event `listenerAdded` or `listenerRemoved`");
    }
    this.logIfDebugEnabled("emitSerial", eventName, eventData);
    const listeners = (_a = getListeners(this, eventName)) != null ? _a : /* @__PURE__ */ new Set();
    const anyListeners = anyMap.get(this);
    const staticListeners = [...listeners];
    const staticAnyListeners = [...anyListeners];
    await resolvedPromise;
    for (const listener of staticListeners) {
      if (listeners.has(listener)) {
        await listener(eventData);
      }
    }
    for (const listener of staticAnyListeners) {
      if (anyListeners.has(listener)) {
        await listener(eventName, eventData);
      }
    }
  }
  onAny(listener, { signal } = {}) {
    assertListener(listener);
    this.logIfDebugEnabled("subscribeAny", void 0, void 0);
    anyMap.get(this).add(listener);
    emitMetaEvent(this, listenerAdded, { listener });
    const offAny = () => {
      this.offAny(listener);
      signal == null ? void 0 : signal.removeEventListener("abort", offAny);
    };
    signal == null ? void 0 : signal.addEventListener("abort", offAny, { once: true });
    if (signal == null ? void 0 : signal.aborted) {
      offAny();
    }
    return offAny;
  }
  anyEvent() {
    return iterator(this);
  }
  offAny(listener) {
    assertListener(listener);
    this.logIfDebugEnabled("unsubscribeAny", void 0, void 0);
    emitMetaEvent(this, listenerRemoved, { listener });
    anyMap.get(this).delete(listener);
  }
  clearListeners(eventNames) {
    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
    for (const eventName of eventNames) {
      this.logIfDebugEnabled("clear", eventName, void 0);
      if (isEventKeyType(eventName)) {
        const set = getListeners(this, eventName);
        if (set) {
          set.clear();
        }
        const producers = getEventProducers(this, eventName);
        if (producers) {
          for (const producer of producers) {
            producer.finish();
          }
          producers.clear();
        }
      } else {
        anyMap.get(this).clear();
        for (const [eventName2, listeners] of eventsMap.get(this).entries()) {
          listeners.clear();
          eventsMap.get(this).delete(eventName2);
        }
        for (const [eventName2, producers] of producersMap.get(this).entries()) {
          for (const producer of producers) {
            producer.finish();
          }
          producers.clear();
          producersMap.get(this).delete(eventName2);
        }
      }
    }
  }
  listenerCount(eventNames) {
    var _a, _b, _c, _d, _e, _f;
    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
    let count = 0;
    for (const eventName of eventNames) {
      if (isEventKeyType(eventName)) {
        count += anyMap.get(this).size + ((_b = (_a = getListeners(this, eventName)) == null ? void 0 : _a.size) != null ? _b : 0) + ((_d = (_c = getEventProducers(this, eventName)) == null ? void 0 : _c.size) != null ? _d : 0) + ((_f = (_e = getEventProducers(this)) == null ? void 0 : _e.size) != null ? _f : 0);
        continue;
      }
      if (eventName !== void 0) {
        assertEventName(eventName);
      }
      count += anyMap.get(this).size;
      for (const value of eventsMap.get(this).values()) {
        count += value.size;
      }
      for (const value of producersMap.get(this).values()) {
        count += value.size;
      }
    }
    return count;
  }
  bindMethods(target, methodNames) {
    if (typeof target !== "object" || target === null) {
      throw new TypeError("`target` must be an object");
    }
    methodNames = defaultMethodNamesOrAssert(methodNames);
    for (const methodName of methodNames) {
      if (target[methodName] !== void 0) {
        throw new Error(`The property \`${methodName}\` already exists on \`target\``);
      }
      Object.defineProperty(target, methodName, {
        enumerable: false,
        value: this[methodName].bind(this)
      });
    }
  }
};
var allEmitteryMethods = Object.getOwnPropertyNames(Emittery.prototype).filter((v) => v !== "constructor");
Object.defineProperty(Emittery, "listenerAdded", {
  value: listenerAdded,
  writable: false,
  enumerable: true,
  configurable: false
});
Object.defineProperty(Emittery, "listenerRemoved", {
  value: listenerRemoved,
  writable: false,
  enumerable: true,
  configurable: false
});

// src/services/jupyter-environment.ts
var import_obsidian2 = require("obsidian");
var import_path = require("path");
var JupyterEnvironment = class {
  constructor(path, printDebug, pythonExecutable, jupyterTimeoutMs, type, customConfigFolderPath, useSimpleMode) {
    this.path = path;
    this.printDebug = printDebug;
    this.pythonExecutable = pythonExecutable;
    this.jupyterTimeoutMs = jupyterTimeoutMs;
    this.type = type;
    this.customConfigFolderPath = customConfigFolderPath;
    this.useSimpleMode = useSimpleMode;
    this.jupyterProcess = null;
    this.jupyterLog = [];
    this.jupyterPort = null;
    this.jupyterToken = null;
    this.events = new Emittery();
    this.status = "exited" /* EXITED */;
    this.aboutToStart = false;
    this.runningType = null;
    this.jupyterExitListener = this.onJupyterExit.bind(this);
    this.jupyterTimoutListener = (0, import_obsidian2.debounce)(
      this.onJupyterTimeout.bind(this),
      this.jupyterTimeoutMs,
      true
    );
    this.jupyerTimedOut = false;
    /**
     * Indicates whether this Jupyter environment instance has been fully
     * loaded. This is set to false once the plugin is done loading.
     *
     * This is used for situations where the vault was closed while a Jupyter
     * view was open, and the vault is reopened. In that case, the Jupyter view
     * will trigger the Jupyter environment to start, but it might not have
     * the right settings values at that point in time.
     *
     * With this flag, the Jupyter environment will wait until the plugin is done
     * loading before it starts. If an attempt is made to start the Jupyter
     * server before the plugin is fully loaded, the starting will be delayed
     * until the plugin is done loading.
     */
    this.fullyLoaded = false;
    /**
     * Indicates whether Jupyter should be started immediately once the
     * plugin is done loading. See {@link fullyLoaded} for more information.
     */
    this.startJupyterOnLoad = false;
  }
  /**
   * Subscribe to one or more events.
   *
   * Using the same listener multiple times for the same event will result
   * in only one method call per emitted event.
   *
   * @returns An unsubscribe method.
   */
  on(event, callback) {
    return this.events.on(event, callback);
  }
  /** Remove one or more event subscriptions. */
  off(event, callback) {
    this.events.off(event, callback);
  }
  /**
   * Subscribe to one or more events only once. It will be unsubscribed
   * after the first event that matches the predicate (if provided).
   *
   * @param event The event name to subscribe to.
   * @param callback The callback function to invoke when the event is
   *   emitted. Should return a boolean indicating whether the listener
   *   should be removed (if the returned value is true, the listener is
   *   removed and won't be called again).
   */
  once(event, callback) {
    this.events.once(event, callback);
  }
  isRunning() {
    return this.jupyterProcess !== null && this.jupyterProcess.exitCode === null && this.status === "running" /* RUNNING */;
  }
  /**
   * Indicates to this Jupyter environment instance that the plugin is
   * done loading. Starting from this point, the Jupyter environment
   * may be started.
   *
   * This is used for situations where the vault was closed while a Jupyter
   * view was open, and the vault is reopened. In that case, the Jupyter view
   * will trigger the Jupyter environment to start, but it might not have
   * the right settings values at that point in time.
   *
   * With this flag, the Jupyter environment will wait until the plugin is done
   * loading before it starts. If an attempt is made to start the Jupyter
   * server before the plugin is fully loaded, the starting will be delayed
   * until the plugin is done loading.
   */
  async endLoading() {
    this.fullyLoaded = true;
    if (this.startJupyterOnLoad) {
      await this.start();
    }
  }
  async start() {
    if (!this.fullyLoaded) {
      this.startJupyterOnLoad = true;
      return;
    }
    if (this.aboutToStart || this.getStatus() !== "exited" /* EXITED */) {
      return;
    }
    this.aboutToStart = true;
    await this.events.emit("about-to-start" /* ABOUT_TO_START */, this);
    this.jupyterLog = [];
    let env = void 0;
    if (this.customConfigFolderPath !== null) {
      env = {
        ...process.env,
        JUPYTER_CONFIG_PATH: `${this.customConfigFolderPath}${process.env.JUPYTER_CONFIG_PATH ? import_path.delimiter + process.env.JUPYTER_CONFIG_PATH : ""}`
      };
    }
    try {
      this.jupyterProcess = (0, import_child_process.spawn)(
        this.pythonExecutable,
        [
          "-m",
          this.type === "notebook" /* NOTEBOOK */ ? "notebook" : "jupyterlab",
          "--no-browser"
        ],
        {
          cwd: this.path,
          env
        }
      );
    } catch (e) {
      this.jupyterProcess = null;
      this.aboutToStart = false;
      await this.events.emit("error" /* ERROR */, [
        this,
        "Jupyter process could not be spawned." /* UNABLE_TO_START_JUPYTER */
      ]);
      return;
    }
    this.jupyterProcess.stderr.on("data", this.processJupyterOutput.bind(this));
    this.jupyterProcess.stdout.on("data", this.processJupyterOutput.bind(this));
    this.jupyterProcess.on("exit", this.jupyterExitListener);
    this.jupyterProcess.on("error", this.jupyterExitListener);
    if (this.jupyterTimeoutMs > 0) {
      this.jupyterTimoutListener();
    }
    this.runningType = this.type;
    this.status = "starting" /* STARTING */;
    this.aboutToStart = false;
    await this.events.emit("starting" /* STARTING */, this);
    await this.events.emit("change" /* CHANGE */, this);
  }
  /**
   * Toggles the Jupyter environment between running and exited.
   *
   * Does nothing if the Jupyter environment is starting.
   */
  async toggle() {
    switch (this.status) {
      case "running" /* RUNNING */:
        this.exit();
        break;
      case "exited" /* EXITED */:
        await this.start();
        break;
    }
  }
  /**
   * Restarts the Jupyter environment.
   *
   * Does nothing if the Jupyter environment is starting.
   */
  async restart() {
    if (this.status === "running" /* RUNNING */) {
      this.exit();
    }
    await this.start();
  }
  onJupyterTimeout() {
    if (this.status == "starting" /* STARTING */) {
      this.jupyerTimedOut = true;
      this.exit();
    }
  }
  async processJupyterOutput(data) {
    data = data.toString();
    this.jupyterLog.push(data);
    if (this.printDebug) {
      console.debug(data.toString());
    }
    if (this.status == "starting" /* STARTING */) {
      const regex = new RegExp(
        `http://localhost:(\\d+)/(?:${this.runningType === "notebook" /* NOTEBOOK */ ? "tree" : "lab"})\\?token=(\\w+)`
      );
      const match = data.match(regex);
      if (match) {
        this.jupyterTimoutListener.cancel();
        this.jupyterPort = parseInt(match[1]);
        this.jupyterToken = match[2];
        this.status = "running" /* RUNNING */;
        await this.events.emit("ready" /* READY */, this);
        await this.events.emit("change" /* CHANGE */, this);
      }
    }
  }
  setPythonExecutable(value) {
    this.pythonExecutable = value;
  }
  printDebugMessages(value) {
    this.printDebug = value;
  }
  setType(value) {
    this.type = value;
  }
  setJupyterTimeoutMs(value) {
    if (value >= 0) {
      this.jupyterTimeoutMs = value;
      if (value > 0) {
        this.jupyterTimoutListener = (0, import_obsidian2.debounce)(
          this.onJupyterTimeout.bind(this),
          this.jupyterTimeoutMs,
          true
        );
      }
    }
  }
  setCustomConfigFolderPath(value) {
    this.customConfigFolderPath = value;
  }
  getCustomConfigFolderPath() {
    return this.customConfigFolderPath;
  }
  setUseSimpleMode(value) {
    this.useSimpleMode = value;
  }
  getUseSimpleMode() {
    return this.useSimpleMode;
  }
  getJupyterTimeoutMs() {
    return this.jupyterTimeoutMs;
  }
  getRunningType() {
    return this.runningType;
  }
  getStatus() {
    return this.status;
  }
  getPort() {
    return this.jupyterPort;
  }
  getToken() {
    return this.jupyterToken;
  }
  getLog() {
    return this.jupyterLog;
  }
  getLastLog() {
    if (this.jupyterLog.length === 0) {
      return "";
    }
    return this.jupyterLog[this.jupyterLog.length - 1];
  }
  /**
   * @param file The path of the file relative to the Jupyter environment's working directory.
   */
  getFileUrl(file) {
    if (!this.isRunning()) {
      return null;
    }
    return "http://localhost:" + this.jupyterPort + "/" + (this.runningType === "notebook" /* NOTEBOOK */ ? "notebooks" : this.useSimpleMode ? "doc/tree" : "lab/tree") + "/" + file + "?token=" + this.jupyterToken;
  }
  exit() {
    if (this.getStatus() !== "exited" /* EXITED */ && this.jupyterProcess !== null) {
      this.jupyterProcess.kill("SIGINT");
    }
  }
  async onJupyterExit(_code, _signal) {
    if (this.jupyterProcess === null) {
      return;
    }
    if (this.jupyterProcess.exitCode !== null && this.jupyterProcess.exitCode !== 0) {
      await this.events.emit("error" /* ERROR */, [
        this,
        "Jupyter process crashed." /* JUPYTER_EXITED_WITH_ERROR */
      ]);
    } else if (this.jupyerTimedOut) {
      this.jupyerTimedOut = false;
      await this.events.emit("error" /* ERROR */, [
        this,
        "Jupyter process took too long to start, assumed something was wrong." /* JUPYTER_STARTING_TIMEOUT */
      ]);
    } else if (this.status === "starting" /* STARTING */) {
      await this.events.emit("error" /* ERROR */, [
        this,
        "Jupyter process exited." /* JUPYTER_EXITED_WITHOUT_ERROR */
      ]);
    }
    this.jupyterProcess = null;
    this.jupyterPort = null;
    this.jupyterToken = null;
    this.runningType = null;
    this.status = "exited" /* EXITED */;
    await this.events.emit("exit" /* EXIT */, this);
    await this.events.emit("change" /* CHANGE */, this);
  }
};

// src/services/jupyter-modal.ts
var import_obsidian3 = require("obsidian");
var JupyterModal = class extends import_obsidian3.Modal {
  constructor(app, heading, message, buttons) {
    super(app);
    this.heading = heading;
    this.message = message;
    this.buttons = buttons;
  }
  onOpen() {
    this.contentEl.createEl("h1", { text: this.heading });
    for (const message of this.message) {
      this.contentEl.createEl("p", { text: message });
    }
    if (this.buttons.length > 0) {
      let setting = new import_obsidian3.Setting(this.contentEl);
      this.buttons.forEach(
        ((button) => {
          setting.addButton(
            ((buttonEl) => {
              buttonEl.setButtonText(button.text);
              buttonEl.onClick(() => {
                button.onClick();
                if (button.closeOnClick) {
                  this.close();
                }
              });
            }).bind(this)
          );
        }).bind(this)
      );
    }
  }
};

// src/services/jupyter-restart-modal.ts
var JupyterRestartModal = class extends JupyterModal {
  constructor(plugin, settingName) {
    super(
      plugin.app,
      "Jupyter restart needed",
      [
        `You just changed the '${settingName}' setting.`,
        "To apply this change, you need to restart Jupyter. Note that restarting Jupyter could cause you to lose your current work if you have not saved it.",
        "Do you want to restart Jupyter now?"
      ],
      [
        {
          text: "No, restart later",
          onClick: () => {
          },
          closeOnClick: true
        },
        {
          text: "Yes, restart now",
          onClick: async () => {
            await plugin.env.restart();
          },
          closeOnClick: true
        }
      ]
    );
  }
};

// src/features/delete-checkpoints/delete-checkpoints-settings.ts
var import_obsidian4 = require("obsidian");
var DEFAULT_DELETE_CHECKPOINTS_SETTINGS = {
  deleteCheckpoints: true,
  moveCheckpointsToTrash: false,
  checkpointsFolder: ""
};
function registerDeleteCheckpointsSettings(tab, defaultCheckpointsRootFolder) {
  tab.registerSetting({
    section: "Jupyter" /* JUPYTER */,
    display: (el, plugin) => {
      new import_obsidian4.Setting(el).setName("Delete Jupyter checkpoints").setDesc(
        "To keep your Obsidian vault clean. Does not work retroactively. Restarting Jupyter is required for the setting to take effect."
      ).addToggle((toggle) => {
        toggle.setValue(plugin.settings.deleteCheckpoints).onChange((value) => {
          plugin.settings.deleteCheckpoints = value;
          if (plugin.env.getStatus() !== "exited" /* EXITED */) {
            new JupyterRestartModal(
              plugin,
              "Delete Jupyter checkpoints"
            ).open();
          }
        });
      });
    }
  });
  tab.registerSetting({
    section: "Jupyter" /* JUPYTER */,
    display: (el, plugin) => {
      new import_obsidian4.Setting(el).setName("Move Jupyter checkpoints to trash").setDesc(
        "Has no effect if 'Delete Jupyter checkpoints' is not enabled. If enabled, checkpoints are moved to system trash. Otherwise, they are permanently deleted."
      ).addToggle((toggle) => {
        toggle.setValue(plugin.settings.moveCheckpointsToTrash).onChange((value) => {
          plugin.settings.moveCheckpointsToTrash = value;
        });
      });
    }
  });
  tab.registerSetting({
    section: "Jupyter" /* JUPYTER */,
    display: (el, plugin) => {
      new import_obsidian4.Setting(el).setName("Jupyter checkpoints folder").setDesc(
        "The root folder for all Jupyter checkpoints. Leave empty for default. Requires restarting Jupyter to take effect. Has no effect if 'Delete Jupyter checkpoints' is not enabled."
      ).addText((text) => {
        var _a;
        text.setPlaceholder(
          (_a = defaultCheckpointsRootFolder.getAbsolutePath()) != null ? _a : "No default path available"
        ).setValue(plugin.settings.checkpointsFolder).onChange((value) => {
          if (value !== "" && !value.endsWith("/")) {
            value += "/";
          }
          plugin.settings.checkpointsFolder = value;
        });
      });
    }
  });
}

// src/features/open-notebooks/open-notebooks-settings.ts
var import_obsidian5 = require("obsidian");
var DEFAULT_OPEN_NOTEBOOKS_SETTINGS = {
  pythonExecutable: "python" /* PYTHON */,
  pythonExecutablePath: "",
  startJupyterAuto: true,
  jupyterEnvType: "lab" /* LAB */,
  useSimpleMode: true,
  displayServerRibbonIcon: true,
  useStatusNotices: true,
  jupyterTimeoutMs: 6e4,
  debugConsole: false
};
function registerOpenNotebookSettingsUI(tab) {
  tab.registerSetting({
    section: "Python" /* PYTHON */,
    display: (el, plugin) => {
      new import_obsidian5.Setting(el).setName("Python executable to use").setDesc(
        "Choose whether to simply use the `python` command or a specific path. Note that you will need to restart your Jupyter server if it is running before this setting is applied."
      ).addDropdown((dropdown) => {
        dropdown.addOption("python" /* PYTHON */, "`python` command").addOption("path" /* PATH */, "Specified executable path").setValue(plugin.settings.pythonExecutable).onChange((value) => {
          plugin.settings.pythonExecutable = value;
        });
      });
    }
  });
  tab.registerSetting({
    section: "Python" /* PYTHON */,
    display: (el, plugin) => {
      new import_obsidian5.Setting(el).setName("Python executable path").setDesc(
        "The path to the Python executable to use. This setting is only used if the previous setting is set to `Specified executable path`."
      ).addText(
        (text) => text.setPlaceholder("Path to Python executable").setValue(plugin.settings.pythonExecutablePath).onChange((value) => {
          plugin.settings.pythonExecutablePath = value;
        })
      );
    }
  });
  tab.registerSetting({
    section: "Jupyter" /* JUPYTER */,
    display: (el, plugin) => {
      new import_obsidian5.Setting(el).setName("Server running").setDesc("Start or stop the Jupyter server.").addToggle(
        (toggle) => toggle.setValue(plugin.env.getStatus() !== "exited" /* EXITED */).onChange(async (value) => {
          if (plugin.env.getStatus() === "starting" /* STARTING */ && !value) {
            toggle.setValue(true);
            new import_obsidian5.Notice("Can't change status while Jupyter server is starting.");
          } else {
            await plugin.env.toggle();
          }
        })
      );
    }
  });
  tab.registerSetting({
    section: "Jupyter" /* JUPYTER */,
    display: (el, plugin) => {
      new import_obsidian5.Setting(el).setName("Start Jupyter automatically").setDesc(
        "If a .ipynb file is opened, a Jupyter server will be started automatically if needed."
      ).addToggle((toggle) => {
        toggle.setValue(plugin.settings.startJupyterAuto).onChange((value) => {
          plugin.settings.startJupyterAuto = value;
        });
      });
    }
  });
  tab.registerSetting({
    section: "Jupyter" /* JUPYTER */,
    display: (el, plugin) => {
      new import_obsidian5.Setting(el).setName("Jupyter environment type").setDesc("Select whether to start Jupyter Notebook or Jupyter Lab.").addDropdown((dropdown) => {
        dropdown.addOption("lab" /* LAB */, "Jupyter Lab").addOption("notebook" /* NOTEBOOK */, "Jupyter Notebook").setValue(plugin.settings.jupyterEnvType).onChange((value) => {
          plugin.settings.jupyterEnvType = value;
          if (plugin.env.getStatus() !== "exited" /* EXITED */) {
            new JupyterRestartModal(plugin, "Jupyter environment type").open();
          }
        });
      });
    }
  });
  tab.registerSetting({
    section: "Jupyter" /* JUPYTER */,
    display: (el, plugin) => {
      new import_obsidian5.Setting(el).setName("Simple interface").setDesc("Whether to use Jupyter's Simple Interface mode when opening a notebook.").addToggle((toggle) => {
        toggle.setValue(plugin.settings.useSimpleMode).onChange((value) => {
          plugin.settings.useSimpleMode = value;
        });
      });
    }
  });
  tab.registerSetting({
    section: "Plugin customization" /* PLUGIN_CUSTOMIZATION */,
    display: (el, plugin) => {
      new import_obsidian5.Setting(el).setName("Ribbon icon for server status").setDesc(
        "Whether to display a ribbon icon that indicates the server status (exited, starting, running), which can be used to start/stop the server."
      ).addToggle(
        (toggle) => toggle.setValue(plugin.settings.displayServerRibbonIcon).onChange((value) => {
          plugin.settings.displayServerRibbonIcon = value;
        })
      );
    }
  });
  tab.registerSetting({
    section: "Plugin customization" /* PLUGIN_CUSTOMIZATION */,
    display: (el, plugin) => {
      new import_obsidian5.Setting(el).setName("Display status notices").setDesc(
        "If enabled, short messages will pop up when the Jupyter server is starting, running or exits."
      ).addToggle(
        (toggle) => toggle.setValue(plugin.settings.useStatusNotices).onChange((value) => {
          plugin.settings.useStatusNotices = value;
        })
      );
    }
  });
  tab.registerSetting({
    section: "Advanced" /* ADVANCED */,
    display: (el, plugin) => {
      new import_obsidian5.Setting(el).setName("Jupyter starting timeout").setDesc(
        "To avoid Jupyter being stuck in the starting phase, a timeout is set by default. You can set how many seconds to wait before killing the Jupyter server. Set to 0 to disable the timeout. Please note that a timeout too small might prevent Jupyter from ever starting."
      ).addSlider((slider) => {
        slider.setLimits(0, 120, 1).setValue(plugin.settings.jupyterTimeoutMs / 1e3).setDynamicTooltip().onChange((value) => {
          plugin.settings.jupyterTimeoutMs = value * 1e3;
        });
      });
    }
  });
  tab.registerSetting({
    section: "Advanced" /* ADVANCED */,
    display: (el, plugin) => {
      new import_obsidian5.Setting(el).setName("Print Jupyter output to Obsidian console.").setDesc(
        "When you start Jupyter through a terminal, it prints a bunch of messages. You can get those messages in the Obsidian console by enabling this setting and opening the console (see key binds on the Obsidian website). This can help you if your Jupyter server does not start for some reason."
      ).addToggle((toggle) => {
        toggle.setValue(plugin.settings.debugConsole).onChange((value) => {
          plugin.settings.debugConsole = value;
        });
      });
    }
  });
}

// src/features/update-modal/update-modal-settings.ts
var import_obsidian6 = require("obsidian");
var DEFAULT_UPDATE_MODAL_SETTINGS = {
  updatePopup: true,
  knownVersion: ""
};
function registerUpdateModalSettingsUI(tab) {
  tab.registerSetting({
    section: "Plugin customization" /* PLUGIN_CUSTOMIZATION */,
    display: (el, plugin) => {
      new import_obsidian6.Setting(el).setName("Update popup").setDesc(
        "When the plugin is updated, a popup is shown with what changes were made."
      ).addToggle((toggle) => {
        toggle.setValue(plugin.settings.updatePopup).onChange((value) => {
          plugin.settings.updatePopup = value;
        });
      });
    }
  });
}

// src/settings/settings.ts
var import_stream = require("stream");
var DEFAULT_SETTINGS = {
  ...DEFAULT_OPEN_NOTEBOOKS_SETTINGS,
  ...DEFAULT_CREATE_NOTEBOOKS_SETTINGS,
  ...DEFAULT_UPDATE_MODAL_SETTINGS,
  ...DEFAULT_DELETE_CHECKPOINTS_SETTINGS
};
var SettingsProxy = class extends import_stream.EventEmitter {
  constructor(initial) {
    super();
    this._settings = { ...initial };
    this.settings = new Proxy(this._settings, {
      get: (target, prop) => target[prop],
      set: (target, prop, value) => {
        const oldValue = target[prop];
        if (oldValue !== value) {
          target[prop] = value;
          this.emit("change", prop, value, oldValue);
          this.emit(`change:${String(prop)}`, value, oldValue);
        }
        return true;
      }
    });
  }
  on(eventName, listener) {
    return super.on(eventName, listener);
  }
  off(eventName, listener) {
    return super.off(eventName, listener);
  }
  once(eventName, listener) {
    return super.once(eventName, listener);
  }
};

// src/settings/settings-tab.ts
var import_obsidian7 = require("obsidian");
var SettingsSection = /* @__PURE__ */ ((SettingsSection2) => {
  SettingsSection2["PYTHON"] = "Python";
  SettingsSection2["JUPYTER"] = "Jupyter";
  SettingsSection2["PLUGIN_CUSTOMIZATION"] = "Plugin customization";
  SettingsSection2["ADVANCED"] = "Advanced";
  return SettingsSection2;
})(SettingsSection || {});
var JupyterSettingsTab5 = class extends import_obsidian7.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    /** List of settings registered by the features. */
    this._settings = Object.values(SettingsSection).reduce(
      (acc, section) => {
        acc[section] = [];
        return acc;
      },
      {}
    );
    this.plugin = plugin;
  }
  /** Way for a feature to add a setting to the UI. */
  registerSetting(setting) {
    this._settings[setting.section].push(setting);
  }
  display() {
    this.containerEl.empty();
    Object.values(SettingsSection).forEach((section) => {
      const settings = this._settings[section];
      if (settings.length < 1) {
        return;
      }
      new import_obsidian7.Setting(this.containerEl).setName(section).setHeading();
      settings.forEach((setting) => setting.display(this.containerEl, this.plugin));
    });
  }
};

// src/features/open-notebooks/open-notebooks-feature.ts
var import_obsidian9 = require("obsidian");

// src/services/jupyter-view.ts
var import_obsidian8 = require("obsidian");
var JUPYTER_VIEW_TYPE = "jupyter-view";
var EmbeddedJupyterView = class extends import_obsidian8.FileView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.changeEventListener = this.onJupyterEnvironmentStatusChange.bind(this);
    this.openedFile = null;
    this.messageContainerEl = null;
    this.messageHeaderEl = null;
    this.messageTextEl = null;
    this.webviewEl = null;
  }
  getViewType() {
    return JUPYTER_VIEW_TYPE;
  }
  getDisplayText() {
    var _a, _b;
    return (_b = (_a = this.openedFile) == null ? void 0 : _a.name) != null ? _b : "New Jupyter tab";
  }
  getIcon() {
    return "none";
  }
  displayMessage(header, text, button = null) {
    this.contentEl.empty();
    this.messageContainerEl = this.contentEl.createDiv();
    this.messageContainerEl.addClass("jupyter-message-container");
    this.messageHeaderEl = this.messageContainerEl.createEl("h2");
    this.messageHeaderEl.addClass("jupyter-message-header");
    this.messageHeaderEl.setText(header);
    this.messageTextEl = this.messageContainerEl.createEl("p");
    this.messageTextEl.addClass("jupyter-message-text");
    this.messageTextEl.setText(text);
    if (button !== null) {
      let buttonEl = new import_obsidian8.ButtonComponent(this.messageContainerEl);
      buttonEl.setButtonText(button.text);
      buttonEl.onClick(button.onClick.bind(this));
    }
  }
  async onLoadFile(file) {
    this.openedFile = file;
    switch (this.plugin.env.getStatus()) {
      case "exited" /* EXITED */:
        if (this.plugin.settings.startJupyterAuto) {
          this.displayExitMessage();
          this.plugin.env.start();
        } else {
          this.displayMessage(
            "No Jupyter server",
            "Jupyter does not seem to be running. Please make sure to start the server manually using the plugin's ribbon icon or settings. You can also enable automatic start of the Jupyter server when a document is opened in the settings.",
            {
              text: "Start Jupyter",
              onClick: () => {
                this.plugin.env.start();
              },
              closeOnClick: false
            }
          );
          return;
        }
        break;
      case "running" /* RUNNING */:
        await this.onJupyterRunning(this.plugin.env);
        break;
      default:
        this.displayMessage(
          "Unknown error",
          "An unknown error has happened when loading the file. Please try closing and re-opening it."
        );
        break;
    }
  }
  async onJupyterEnvironmentStatusChange(env) {
    switch (env.getStatus()) {
      case "starting" /* STARTING */:
        this.displayMessage(
          "Jupyter is starting",
          "The Jupyter server is not ready yet. Your document will be opened shortly."
        );
        break;
      case "running" /* RUNNING */:
        await this.onJupyterRunning(env);
        break;
      case "exited" /* EXITED */:
        this.displayExitMessage();
        break;
      default:
        this.displayMessage(
          "Unknown error",
          "An unknown error has happened when loading the file. Please try closing and re-opening it."
        );
        break;
    }
  }
  displayExitMessage() {
    this.displayMessage(
      "Jupyter server exited",
      "The Jupyter server has exited. Please restart the server to view the file.",
      {
        text: "Start Jupyter",
        onClick: () => {
          this.plugin.env.start();
        },
        closeOnClick: false
      }
    );
  }
  async onJupyterRunning(env) {
    if (this.openedFile === null) {
      this.displayMessage(
        "No opened file",
        "Click on a file in the explorer view to open it here."
      );
      return;
    }
    if (!env.isRunning()) {
      this.displayMessage(
        "Unknown error",
        "An unknown error has happened when loading the page. Please try closing and re-opening it."
      );
      return;
    }
    this.contentEl.empty();
    this.displayMessage(
      "Loading " + this.openedFile.name,
      "Your file will be displayed shortly."
    );
    this.webviewEl = this.contentEl.createEl("webview");
    this.webviewEl.setAttribute("allowpopups", "");
    this.webviewEl.setAttribute("partition", "persist:surfing-vault-" + this.app.appId);
    this.webviewEl.addClass("jupyter-webview", "jupyter-webview-loading");
    this.webviewEl.setAttribute("src", env.getFileUrl(this.openedFile.path));
    this.webviewEl.addEventListener(
      "dom-ready",
      ((_event) => {
        var _a, _b, _c, _d;
        (_a = this.messageContainerEl) == null ? void 0 : _a.remove();
        this.messageContainerEl = null;
        (_b = this.messageHeaderEl) == null ? void 0 : _b.remove();
        this.messageHeaderEl = null;
        (_c = this.messageTextEl) == null ? void 0 : _c.remove();
        this.messageTextEl = null;
        (_d = this.webviewEl) == null ? void 0 : _d.removeClass("jupyter-webview-loading");
      }).bind(this)
    );
  }
  async onOpen() {
    this.plugin.env.on("change" /* CHANGE */, this.changeEventListener);
  }
  async onClose() {
    this.openedFile = null;
    this.messageContainerEl = null;
    this.messageHeaderEl = null;
    this.messageTextEl = null;
    this.webviewEl = null;
    this.plugin.env.off("change" /* CHANGE */, this.changeEventListener);
  }
};

// src/features/open-notebooks/open-notebooks-feature.ts
var OpenNotebooksFeature = class {
  constructor() {
    this.serverRibbonIcon = null;
  }
  async onload(plugin) {
    this.plugin = plugin;
    this.configureJupyterEnvironment(
      this.plugin.env,
      this.plugin.settings,
      this.plugin.settingsProxy
    );
    registerOpenNotebookSettingsUI(this.plugin.settingsTab);
    if (this.plugin.settings.displayServerRibbonIcon) {
      this.serverRibbonIcon = this.plugin.addRibbonIcon(
        "monitor-play",
        "Start Jupyter Server",
        this.plugin.env.toggle.bind(this.plugin.env)
      );
    }
    this.plugin.env.on("change" /* CHANGE */, (env) => this.updateRibbon(env));
    this.plugin.env.on("change" /* CHANGE */, () => this.showStatusMessage());
    this.plugin.env.on(
      "error" /* ERROR */,
      (args) => this.onEnvironmentError(...args)
    );
    this.plugin.registerView(
      "jupyter-view",
      (leaf) => new EmbeddedJupyterView(leaf, this.plugin)
    );
    this.plugin.registerExtensions(["ipynb"], "jupyter-view");
  }
  /**
   * Displays a status notice whenever the Jupyter environment status
   * changes, except if the user has disabled status notices.
   */
  showStatusMessage() {
    if (!this.plugin.settings.useStatusNotices) {
      return;
    }
    switch (this.plugin.env.getStatus()) {
      case "starting" /* STARTING */:
        new import_obsidian9.Notice("Jupyter Server is starting");
        break;
      case "running" /* RUNNING */:
        new import_obsidian9.Notice("Jupyter Server is now running");
        break;
      case "exited" /* EXITED */:
        new import_obsidian9.Notice("Jupyter Server has exited");
        break;
    }
  }
  /**
   * Every time the Jupyter environment status changes, this method
   * updates the ribbon icon to reflect the current status (one
   * icon corresponds to one specific status).
   */
  async updateRibbon(env) {
    if (this.serverRibbonIcon === null || !this.plugin.settings.displayServerRibbonIcon) {
      return;
    }
    switch (env.getStatus()) {
      case "starting" /* STARTING */:
        (0, import_obsidian9.setIcon)(this.serverRibbonIcon, "monitor-dot");
        (0, import_obsidian9.setTooltip)(this.serverRibbonIcon, "Jupyter Server is starting");
        break;
      case "running" /* RUNNING */:
        (0, import_obsidian9.setIcon)(this.serverRibbonIcon, "monitor-stop");
        (0, import_obsidian9.setTooltip)(this.serverRibbonIcon, "Stop Jupyter Server");
        break;
      case "exited" /* EXITED */:
        (0, import_obsidian9.setIcon)(this.serverRibbonIcon, "monitor-play");
        (0, import_obsidian9.setTooltip)(this.serverRibbonIcon, "Start Jupyter Server");
        break;
    }
  }
  /**
   * Handles errors that occur in the Jupyter environment by displaying a
   * modal with information about the error and a link to the
   * troubleshooting guide.
   */
  onEnvironmentError(_env, error) {
    if (error === "Jupyter process took too long to start, assumed something was wrong." /* JUPYTER_STARTING_TIMEOUT */) {
      new JupyterModal(
        this.plugin.app,
        "Jupyter Timeout",
        [
          "The Jupyter server took too long to start.",
          "You can set in the settings the maximum time the plugin will wait for the server to start.",
          "Your current timeout is set to " + this.plugin.settings.jupyterTimeoutMs / 1e3 + " second(s).",
          this.plugin.settings.jupyterTimeoutMs < 15e3 ? "This is a very short timeout and might not be enough for the server to start. Please try increasing it and see if the error disappears." : "This timeout seems reasonable, hence the problem might be elsewhere depending on your specific situation."
        ],
        [
          {
            text: "Open troubleshooting guide",
            onClick: () => {
              window.open(
                "https://jupyter.mael.im/troubleshooting#jupyter-timeout",
                "_blank"
              );
            },
            closeOnClick: false
          }
        ]
      ).open();
    } else if (error === "Jupyter process could not be spawned." /* UNABLE_TO_START_JUPYTER */) {
      new JupyterModal(
        this.plugin.app,
        "Couldn't start Jupyter",
        [
          "Jupyter could not even be started.",
          "Please check your Python executable and make sure Jupyter is installed in the corresponding environment.",
          "Use the button below to open the troubleshooting guide."
        ],
        [
          {
            text: "Open troubleshooting guide",
            onClick: () => {
              window.open(
                "https://jupyter.mael.im/troubleshooting#jupyter-process-could-not-be-spawned",
                "_blank"
              );
            },
            closeOnClick: false
          }
        ]
      );
    } else if (error === "Jupyter process crashed." /* JUPYTER_EXITED_WITH_ERROR */) {
      new JupyterModal(
        this.plugin.app,
        "Jupyter crashed",
        [
          "Jupyter crashed while starting",
          "Use the button below to open the troubleshooting guide.",
          "Here is the last log message from Jupyter:",
          this.plugin.env.getLastLog()
        ],
        [
          {
            text: "Open troubleshooting guide",
            onClick: () => {
              window.open(
                "https://jupyter.mael.im/troubleshooting#jupyter-process-crashed",
                "_blank"
              );
            },
            closeOnClick: false
          }
        ]
      ).open();
    } else {
      new JupyterModal(
        this.plugin.app,
        "Jupyter exited",
        [
          "Jupyter crashed while starting but did not encounter an error.",
          "This is a very rare case and might be due to an 'exit()' statement that got lost in your Jupyter configuration.",
          "Use the button below to open the troubleshooting guide.",
          "Here is the last log message from Jupyter:",
          this.plugin.env.getLastLog()
        ],
        [
          {
            text: "Open troubleshooting guide",
            onClick: () => {
              window.open(
                "https://jupyter.mael.im/troubleshooting#jupyter-process-exited",
                "_blank"
              );
            },
            closeOnClick: false
          }
        ]
      ).open();
    }
  }
  /**
   * Configures the Jupyter environment with the current settings
   * and sets up listeners to update the environment
   * whenever the settings change.
   */
  configureJupyterEnvironment(env, settings, proxy) {
    proxy.on("change:debugConsole", (newVal, _oldVal) => {
      env.printDebugMessages(newVal);
    });
    env.printDebugMessages(settings.debugConsole);
    proxy.on("change:pythonExecutable", (newVal, _oldVal) => {
      env.setPythonExecutable(
        newVal === "python" /* PYTHON */ ? "python" : settings.pythonExecutablePath
      );
    });
    proxy.on("change:pythonExecutablePath", (newVal, _oldVal) => {
      if (settings.pythonExecutable === "path" /* PATH */) {
        env.setPythonExecutable(newVal);
      }
    });
    env.setPythonExecutable(
      settings.pythonExecutable === "python" /* PYTHON */ ? "python" : settings.pythonExecutablePath
    );
    proxy.on("change:jupyterTimeoutMs", (newVal, _oldVal) => {
      env.setJupyterTimeoutMs(newVal);
    });
    env.setJupyterTimeoutMs(settings.jupyterTimeoutMs);
    proxy.on("change:jupyterEnvType", (newVal, _oldVal) => {
      env.setType(newVal);
    });
    env.setType(settings.jupyterEnvType);
    proxy.on("change:useSimpleMode", (newVal, _oldVal) => {
      env.setUseSimpleMode(newVal);
    });
    env.setUseSimpleMode(settings.useSimpleMode);
    proxy.on("change:displayServerRibbonIcon", (newVal, _oldVal) => {
      var _a;
      if (newVal) {
        this.serverRibbonIcon = this.plugin.addRibbonIcon(
          "monitor-play",
          "Start Jupyter Server",
          this.plugin.env.toggle.bind(this.plugin.env)
        );
        this.updateRibbon(this.plugin.env);
      } else {
        (_a = this.serverRibbonIcon) == null ? void 0 : _a.remove();
        this.serverRibbonIcon = null;
      }
    });
  }
};

// src/features/create-notebooks/create-notebooks-feature.ts
var import_obsidian11 = require("obsidian");

// src/services/jupyter-path.ts
var import_obsidian10 = require("obsidian");
function getVaultRootPath(vault) {
  if (vault.adapter instanceof import_obsidian10.FileSystemAdapter) {
    let basePath = vault.adapter.getBasePath();
    if (!basePath.endsWith("/")) {
      basePath += "/";
    }
    return basePath;
  } else {
    throw new Error(
      "Invalid environment : Jupyter for Obsidian needs a FileSystemAdapter instance to work with absolute paths."
    );
  }
}
function inVault(path, vault, root = null) {
  if (path instanceof JupyterAbstractPath) {
    path = path.getAbsolutePath();
  }
  if (root === null) {
    root = getVaultRootPath(vault);
  }
  return path.startsWith(root) || path + "/" === root;
}
var JupyterAbstractPath = class {
  /**
   * Represent a file or a folder in the file system, with information relevant to the Jupyter for Obsidian plugin.
   *
   * @param absolute The absolute path to the represented file or folder.
   * @param relative The relative path to the represented file or folder if within the vault, null otherwise.
   * @param isFolder Whether the represented entity is a folder.
   * @param isInVault Whether the represented entity (file or folder) lies within the current Obsidian vault.
   *
   * @throws If `isInVault` is set to `true` but no relative path is provided (`relative` is set to `null`), an error is thrown.
   */
  constructor(absolute, relative, isFolder, isInVault) {
    absolute = (0, import_obsidian10.normalizePath)(absolute);
    if (isFolder && !absolute.endsWith("/")) {
      absolute += "/";
    } else if (!isFolder && absolute.endsWith("/")) {
      absolute = absolute.substring(0, absolute.length - 1);
    }
    this.absolutePath = absolute;
    if (!isInVault) {
      this.relativePath = null;
    } else if (relative === null) {
      throw new Error(
        "Invalid argument in JupyterAbstractPath constructor : `relative` must not be `null` if `isInVault` is set to `true`"
      );
    } else {
      if (isFolder && !relative.endsWith("/")) {
        relative += "/";
      } else if (!isFolder && relative.endsWith("/")) {
        relative = relative.substring(0, relative.length - 1);
      }
      this.relativePath = relative;
    }
    this.isDirectory = isFolder;
    this.isInVault = isInVault;
  }
  /**
   * The absolute path of the file/folder, for example "C:/some/path/".
   *
   * This path is guaranteed to be normalized in the sense of Obsidian's normalizePath method.
   *
   * If the instance is a folder, the absolute path is guaranteed to end with "/".
   */
  getAbsolutePath() {
    return this.absolutePath;
  }
  /**
   * The path of the file/folder relative to the current Obsidian vault, for example "Digital Garden/Home.md".
   *
   * This path is guaranteed to be normalized in the sense of Obsidian's normalizePath method.
   *
   * If the instance is a folder, the relative path is guaranteed to end with "/".
   *
   * If the file or folder is not within the current Obsidian vault, this value is guaranteed to be null.
   */
  getRelativePath() {
    if (!this.isInVault) {
      return null;
    }
    return this.relativePath;
  }
  /**
   * Whether the instance is a folder or not.
   */
  isFolder() {
    return this.isDirectory;
  }
  /**
   * Whether the instance represents a file or folder inside the current Obsidian vault or not.
   */
  inVault() {
    return this.isInVault;
  }
  /**
   * Returns a new path instance with the provided relative path appended to the original
   * path contained by the current instance. Does not modify the current instance.
   *
   * Not that this method will not check whether the resulting path is within the vault or not.
   * Thus, if you have a vault with a root path of "/home/obsidian/", and you call this method
   * on a path "/home/" to append "obsidian/" to it, the resulting path would semantically be
   * within the vault, but the method will not check that and will return a path that indicates
   * it is not in the vault.
   *
   * @param relativePath The path to add to the end of the current instance's path.
   * @param isFolder     Whether the represented path of the new instance will be a folder
   *                     (or not, in which case it is a file).
   *
   * @throws If the current instance is not a folder.
   */
  append(relativePath, isFolder) {
    if (!this.isFolder()) {
      throw new Error(
        "Cannot append a path to a file, the instance must represent a folder."
      );
    }
    if (relativePath.startsWith("/")) {
      relativePath = relativePath.substring(1);
    }
    return new JupyterAbstractPath(
      this.absolutePath + relativePath,
      this.relativePath === null ? null : this.relativePath + relativePath,
      isFolder,
      this.inVault()
    );
  }
  /**
   * Utility function to ease the creation of a Jupyter abstract path.
   *
   * Simply give the absolute path of the file/folder and indicate which of the two it is.
   *
   * @param absolute The absolute path to the file/folder to represent.
   * @param isFolder Whether it is a folder (or not, in which case it is a file).
   *
   * @throws If the provided vault does not have a FileSystemAdapter instance attached to it.
   */
  static fromAbsolute(absolute, isFolder, vault) {
    const vaultRoot = getVaultRootPath(vault);
    const isInVault = inVault(absolute, vault, vaultRoot);
    const relative = isInVault ? absolute.substring(vaultRoot.length) : null;
    return new JupyterAbstractPath(absolute, relative, isFolder, isInVault);
  }
  /**
   * Utility function to ease the creation of a Jupyter abstract path.
   *
   * Simply give the relative path of the file/folder and indicate which of the two it is.
   *
   * @param relative The path to the file/folder relative to the vault's root.
   * @param isFolder Whether it is a folder (or not, in which case it is a file).
   *
   * @throws If the provided vault does not have a FileSystemAdapter instance attached to it.
   */
  static fromRelative(relative, isFolder, vault) {
    let vaultRoot = getVaultRootPath(vault);
    if (!vaultRoot.endsWith("/")) {
      vaultRoot = vaultRoot + "/";
    }
    if (relative.startsWith("/")) {
      relative = relative.substring(1);
    }
    return new JupyterAbstractPath(vaultRoot + relative, relative, isFolder, true);
  }
};

// src/features/create-notebooks/create-notebooks-feature.ts
var CreateNotebooksFeature = class {
  constructor() {
    /**
     * The ribbon icon used to create Jupyter notebooks.
     *
     * Since the user can show/hide the ribbon icon in the settings, a
     * reference to the icon is kept here so that it can be removed
     * later if needed.
     */
    this.fileRibbonIcon = null;
    /**
     * Handler that gets called by Obsidian when the user right-clicks a
     * file or folder in the file explorer.
     *
     * Used to display a context menu item to create a new Jupyter notebook
     * in the folder that was right-clicked.
     *
     * Kept as a class property so that it can be removed later
     * if the user disables the context menu item in the settings.
     */
    this.onFileContextMenu = this.onFileContextMenuOpened.bind(this);
  }
  async onload(plugin) {
    this.plugin = plugin;
    registerCreateNotebooksSettingsUI(this.plugin.settingsTab);
    (0, import_obsidian11.addIcon)(
      "jupyter-logo",
      `<path fill="currentColor" d="m 51.4537,74.98344 c -15.406714,0 -29.180954,-5.68784 -36.479994,-13.79248 2.83328,7.29904 7.71248,13.79248 14.187674,18.24 6.493446,4.46576 14.187686,6.8856 22.29232,6.8856 8.10464,0 15.82016,-2.41984 22.29232,-6.8856 C 80.239467,74.98344 85.100427,68.49 87.933707,61.19096 80.634667,69.29864 66.86042,74.98344 51.4537,74.98344 Z m 0,-53.5192 c 15.40672,0 29.180967,5.68784 36.480007,13.79248 -2.83328,-7.29904 -7.69424,-13.79248 -14.187687,-18.24 -6.8856,-4.86096 -14.57984,-7.29904 -22.29232,-7.29904 -8.107674,0 -15.798874,2.44112 -22.29232,6.8856 C 22.689226,21.46424 17.806986,27.54424 14.973706,35.25672 22.272746,26.7356 35.654826,21.46424 51.4537,21.46424 Z M 79.829067,2.02344 c -7.566567,0 -7.566567,11.33312 0,11.33312 7.56656,0 7.56656,-11.33312 0,-11.33312 z M 22.689226,83.89672 c -4.04016,0 -7.299046,3.25888 -7.299046,7.29904 0,4.02192 3.258886,7.2808 7.299046,7.2808 4.021914,0 7.280794,-3.25888 7.280794,-7.2808 0,-4.04016 -3.258874,-7.29904 -7.280794,-7.29904 z m -6.08,-72.96 c -5.414243,0 -5.414243,8.10768 0,8.10768 5.399034,0 5.399034,-8.10768 0,-8.10768 z" id="path1" style="stroke-width:3.04" />`
    );
    if (this.plugin.settings.displayFileRibbonIcon) {
      this.fileRibbonIcon = this.plugin.addRibbonIcon(
        "jupyter-logo",
        "Create Jupyter Notebook",
        this.onFileRibbonIconClicked.bind(this)
      );
    }
    this.plugin.settingsProxy.on("change:displayFileRibbonIcon", (newVal, _oldVal) => {
      var _a;
      if (newVal) {
        this.fileRibbonIcon = this.plugin.addRibbonIcon(
          "jupyter-logo",
          "Create Jupyter Notebook",
          this.onFileRibbonIconClicked.bind(this)
        );
      } else {
        (_a = this.fileRibbonIcon) == null ? void 0 : _a.remove();
        this.fileRibbonIcon = null;
      }
    });
    if (this.plugin.settings.displayFolderContextMenuItem) {
      this.plugin.app.workspace.on("file-menu", this.onFileContextMenu);
    }
    this.plugin.settingsProxy.on("change:displayFolderContextMenuItem", (newVal, _oldVal) => {
      if (newVal) {
        this.plugin.app.workspace.on("file-menu", this.onFileContextMenu);
      } else {
        this.plugin.app.workspace.off("file-menu", this.onFileContextMenu);
      }
    });
    this.plugin.addCommand({
      id: "jupyter-create-notebook",
      name: "Create new Jupyter notebook",
      callback: (async () => {
        await this.createJupyterNotebook(
          JupyterAbstractPath.fromRelative("/", true, this.plugin.app.vault)
        );
      }).bind(this)
    });
  }
  /** Event handler for when the ribbon icon is clicked. */
  async onFileRibbonIconClicked() {
    await this.createJupyterNotebook(
      JupyterAbstractPath.fromRelative("/", true, this.plugin.app.vault)
    );
  }
  /** Triggered by Obsidian when the user right clicks a file or folder. */
  onFileContextMenuOpened(menu, file, _source, _leaf) {
    if (file instanceof import_obsidian11.TFolder) {
      menu.addItem((item) => {
        item.setTitle("New Jupyter notebook").setIcon("jupyter-logo").setSection("action-primary").onClick(async (_event) => {
          await this.createJupyterNotebook(
            JupyterAbstractPath.fromRelative(file.path, true, this.plugin.app.vault)
          );
        });
      });
    }
  }
  /** Creates a new Jupyter notebook in the specified folder. */
  async createJupyterNotebook(folder) {
    if (!folder.inVault()) {
      throw new Error("Creating a new notebook can only be done within the vault.");
    }
    const file = folder.append(this.getDefaultNotebookFilename(), false);
    if (await this.plugin.app.vault.adapter.exists(file.getRelativePath())) {
      new import_obsidian11.Notice(
        `The file "${file.getRelativePath()}" already exists, creation was aborted to avoid overwriting it. Please try again.`
      );
    }
    await this.plugin.app.vault.adapter.write(
      file.getRelativePath(),
      `{"cells": [],"metadata": {"kernelspec": {"display_name": "","name": ""},"language_info": {"name": ""}},"nbformat": 4,"nbformat_minor": 5}`
    );
    if (this.plugin.settings.openCreatedFileMode !== "dont-open" /* DONT */) {
      let newLeaf;
      switch (this.plugin.settings.openCreatedFileMode) {
        case "current-tab" /* CURRENT_TAB */:
          newLeaf = false;
          break;
        case "new-tab" /* NEW_TAB */:
          newLeaf = "tab";
          break;
        case "split" /* SPLIT */:
          newLeaf = "split";
          break;
        case "detached-window" /* WINDOW */:
          newLeaf = "window";
          break;
      }
      const leaf = this.plugin.app.workspace.getLeaf(newLeaf);
      leaf.openFile(
        this.plugin.app.vault.getFileByPath(file.getRelativePath())
      );
    }
  }
  /**
   * Builds a default filename for a new Jupyter notebook using the current
   * date and time.
   */
  getDefaultNotebookFilename() {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, "0");
    const day = String(now.getDate()).padStart(2, "0");
    const hours = String(now.getHours()).padStart(2, "0");
    const minutes = String(now.getMinutes()).padStart(2, "0");
    const seconds = String(now.getSeconds()).padStart(2, "0");
    return `Jupyter Notebook ${year}-${month}-${day}-${hours}-${minutes}-${seconds}.ipynb`;
  }
  onunload() {
    var _a;
    this.plugin.app.workspace.off("file-menu", this.onFileContextMenu);
    (_a = this.fileRibbonIcon) == null ? void 0 : _a.remove();
    this.fileRibbonIcon = null;
  }
};

// src/features/update-modal/jupyter-update-modal.ts
var import_obsidian12 = require("obsidian");
async function getReleaseNotes(repoOwner, repoName, fromRelease, toRelease) {
  var _a;
  const response = await fetch(`https://api.github.com/repos/${repoOwner}/${repoName}/releases`);
  const releases = await response.json();
  if (!response.ok && "message" in releases || !Array.isArray(releases)) {
    throw new Error(`Failed to fetch releases: ${(_a = releases.message) != null ? _a : "Unknown error"}`);
  }
  const firstReleaseIndex = fromRelease === "" ? releases.length : releases.findIndex((release) => release.tag_name === fromRelease);
  if (firstReleaseIndex === -1) {
    throw new Error(`Could not find release with tag ${fromRelease}`);
  }
  const lastReleaseIndex = toRelease === "" ? 0 : releases.findIndex((release) => release.tag_name === toRelease);
  if (lastReleaseIndex === -1) {
    throw new Error(`Could not find release with tag ${toRelease}`);
  }
  const beta = fromRelease.endsWith("-beta");
  return releases.slice(lastReleaseIndex, firstReleaseIndex).filter((release) => !release.draft && (beta || !release.prerelease));
}
function addExtraHashToHeadings(markdownText, numHashes = 1) {
  const lines = markdownText.split("\n");
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].startsWith("#")) {
      lines[i] = "#".repeat(numHashes) + lines[i];
    }
  }
  return lines.join("\n");
}
var UpdateModal = class extends import_obsidian12.Modal {
  constructor(app, plugin, lastAnnouncedVersion, versionToAnnounce) {
    super(app);
    this.plugin = plugin;
    this.lastAnnounced = lastAnnouncedVersion;
    this.toAnnounce = versionToAnnounce;
    void this.loadReleaseNotes();
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h1", {
      text: "Fetching release notes..."
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  async loadReleaseNotes() {
    try {
      this.releases = await getReleaseNotes(
        "MaelImhof",
        "obsidian-jupyter",
        this.lastAnnounced,
        this.toAnnounce
      );
      if (this.releases.length === 0) {
        this.close();
        return;
      }
      this.display();
    } catch (err) {
      this.releases = [];
      this.display();
    }
  }
  display() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h1", {
      text: `Jupyter for Obsidian v${this.toAnnounce}`
    });
    contentEl.createEl("p", {
      text: "Hi !"
    });
    contentEl.createEl("p", {
      text: "Thank you for using Jupyter for Obsidian, hope you like it so far ! I'd love to have your feedback if you have some time."
    });
    new import_obsidian12.Setting(contentEl).addButton(
      ((feedbackBtn) => {
        feedbackBtn.setIcon("message-circle").setButtonText("Give feedback").onClick(() => {
          window.open("https://jupyter.mael.im/#providing-feedback", "_blank");
        });
      }).bind(this)
    ).addButton(
      ((disableBtn) => {
        disableBtn.setIcon("megaphone-off").setButtonText("Disable update popups").onClick(
          (() => {
            this.plugin.settings.updatePopup = false;
            new import_obsidian12.Notice(
              "Jupyter for Obsidian won't display update popups anymore."
            );
          }).bind(this)
        );
      }).bind(this)
    );
    const contentDiv = contentEl.createDiv();
    if (!this.releases || this.releases.length === 0) {
      void import_obsidian12.MarkdownRenderer.render(
        this.app,
        `> [!FAILURE]
> Release notes could not be retrieved. You can still look at the last releases [on GitHub](https://github.com/MaelImhof/obsidian-jupyter/releases) directly.`,
        contentDiv,
        this.app.vault.getRoot().path,
        new import_obsidian12.Component()
      );
    } else {
      contentEl.createEl("h2", {
        text: "What changed?"
      });
      const changeLogRegex = /## Change Log\s{1,5}([\s\S]*)$/;
      const releaseNotes = this.releases.map((release) => {
        const results = release.body.match(changeLogRegex);
        let changelog = results === null ? "Could not load this changelog." : results[1];
        return `### [Jupyter for Obsidian v${release.tag_name}](https://github.com/MaelImhof/obsidian-jupyter/releases/tag/${release.tag_name})

${addExtraHashToHeadings(changelog)}`;
      }).join("\n---\n");
      void import_obsidian12.MarkdownRenderer.render(
        this.app,
        releaseNotes,
        contentDiv,
        this.app.vault.getRoot().path,
        new import_obsidian12.Component()
      );
    }
  }
};

// src/features/update-modal/update-modal-feature.ts
var UpdateModalFeature = class {
  async onload(plugin) {
    this.plugin = plugin;
    registerUpdateModalSettingsUI(this.plugin.settingsTab);
    this.announceUpdate();
  }
  /**
   * Checks whether the plugin has been updated and displays a
   * popup message if it has.
   *
   * Strongly inspired from the QuickAdd implementation :
   * https://github.com/chhoumann/quickadd/blob/08f269393c3cec5bf0c1d64a79d7999afd0a35a9/src/main.ts#L210
   */
  announceUpdate() {
    const currentVersion = this.plugin.manifest.version;
    const knownVersion = this.plugin.settings.knownVersion;
    if (knownVersion === "") {
      this.plugin.settings.knownVersion = currentVersion;
      return;
    }
    if (knownVersion === currentVersion) {
      return;
    }
    this.plugin.settings.knownVersion = currentVersion;
    if (!this.plugin.settings.updatePopup)
      return;
    const updateModal = new UpdateModal(
      this.plugin.app,
      this.plugin,
      knownVersion,
      currentVersion
    );
    updateModal.open();
  }
};

// src/services/path-utils.ts
function getPluginFolder(plugin) {
  return JupyterAbstractPath.fromRelative(
    plugin.app.vault.configDir + "/plugins/" + plugin.manifest.id + "/",
    true,
    plugin.app.vault
  );
}

// src/features/delete-checkpoints/jupyter-checkpoints-utils.ts
var import_fs = require("fs");
var import_obsidian13 = require("obsidian");
function getDefaultCheckpointsRootFolder(plugin) {
  const pluginFolder = getPluginFolder(plugin);
  return pluginFolder.append(".ipynb_checkpoints/", true);
}
function getCheckpointsRootFolder(plugin) {
  if (!(plugin.app.vault.adapter instanceof import_obsidian13.FileSystemAdapter)) {
    throw new Error(
      "Invalid environment : need a file system adapter to work with files outside of the vault (Jupyter for Obsidian)."
    );
  }
  if (plugin.settings.checkpointsFolder !== "") {
    return JupyterAbstractPath.fromAbsolute(
      plugin.settings.checkpointsFolder + ".ipynb_checkpoints",
      true,
      plugin.app.vault
    );
  } else {
    return getDefaultCheckpointsRootFolder(plugin);
  }
}
async function purgeJupyterCheckpoints(plugin) {
  let checkpointsFolder;
  try {
    checkpointsFolder = getCheckpointsRootFolder(plugin);
  } catch (e) {
    return;
  }
  if (!(0, import_fs.existsSync)(checkpointsFolder.getAbsolutePath())) {
    return;
  }
  if (!plugin.settings.deleteCheckpoints || plugin.settings.moveCheckpointsToTrash) {
    if (checkpointsFolder.inVault()) {
      plugin.app.vault.adapter.trashSystem(checkpointsFolder.getRelativePath());
    } else {
      new import_obsidian13.Notice(
        "[Jupyter for Obsidian] ERROR\n\nMoving the Jupyter checkpoints to the system trash is only possible when the checkpoints are stored inside of the vault.\n\nPlease consider changing either the checkpoints folder path setting to one that is inside the vault, or define the checkpoints to be deleted without going to the trash.\n\nYour checkpoints were not deleted nor moved to the trash.",
        0
      );
    }
  } else {
    if (checkpointsFolder.inVault()) {
      plugin.app.vault.adapter.rmdir(checkpointsFolder.getRelativePath(), true);
    } else {
      (0, import_fs.rmdirSync)(checkpointsFolder.getAbsolutePath(), { recursive: true });
    }
  }
}

// src/features/delete-checkpoints/jupyter-config-utils.ts
var import_obsidian14 = require("obsidian");
function getJupyterConfigPath(plugin) {
  const pluginFolder = getPluginFolder(plugin);
  return pluginFolder.append("jupyter_lab_config.py", false);
}
async function customJupyterConfigExists(plugin) {
  let configPath;
  try {
    configPath = getJupyterConfigPath(plugin);
  } catch (e) {
    return false;
  }
  if (!configPath.inVault()) {
    return false;
  }
  return await plugin.app.vault.adapter.exists(
    (0, import_obsidian14.normalizePath)(configPath.getRelativePath())
  );
}
async function generateJupyterConfig(plugin) {
  let checkpointsFolder;
  let configPath;
  try {
    checkpointsFolder = getCheckpointsRootFolder(plugin);
    configPath = getJupyterConfigPath(plugin);
  } catch (e) {
    return false;
  }
  if (!configPath.inVault()) {
    return false;
  }
  const configContent = `c.FileContentsManager.checkpoints_kwargs = {'root_dir': r'${checkpointsFolder.getAbsolutePath()}'}
print("[Jupyter for Obsidian] Custom configuration of Jupyter for Obsidian loaded successfully.")`;
  await plugin.app.vault.adapter.write(
    (0, import_obsidian14.normalizePath)(configPath.getRelativePath()),
    configContent
  );
  return true;
}

// src/features/delete-checkpoints/delete-checkpoints-feature.ts
var DeleteCheckpointsFeature = class {
  async onload(plugin) {
    this.plugin = plugin;
    this.plugin.env.on("exit" /* EXIT */, (env) => this.onJupyterExit(env));
    this.plugin.env.on(
      "about-to-start" /* ABOUT_TO_START */,
      () => this.setupBasedOnSettings()
    );
    registerDeleteCheckpointsSettings(
      this.plugin.settingsTab,
      getDefaultCheckpointsRootFolder(this.plugin)
    );
    this.plugin.settingsProxy.on("change:checkpointsFolder", (newVal, _oldVal) => {
      if (newVal !== "" && !newVal.endsWith("/")) {
        newVal += "/";
        this.plugin.settings.checkpointsFolder = newVal;
      }
    });
    if (this.plugin.settings.checkpointsFolder !== "" && !this.plugin.settings.checkpointsFolder.endsWith("/")) {
      this.plugin.settings.checkpointsFolder += "/";
    }
  }
  /**
   * Called right before the Jupyter environment starts. Performs
   * last-minute configuration based on the current settings.
   *
   * If checkpoints deletion is enabled, creates a custom Jupyter
   * configuration file to tell Jupyter to put all checkpoints in a
   * single place. Also configures the environment to use this
   * Jupyter configuration file.
   */
  async setupBasedOnSettings() {
    if (this.plugin.settings.deleteCheckpoints) {
      this.plugin.env.setCustomConfigFolderPath(
        getPluginFolder(this.plugin).getAbsolutePath()
      );
      if (!await customJupyterConfigExists(this.plugin)) {
        await generateJupyterConfig(this.plugin);
      }
    } else {
      this.plugin.env.setCustomConfigFolderPath(null);
    }
  }
  /** Whenever the Jupyter environment is stopped, delete checkpoints. */
  async onJupyterExit(_env) {
    await purgeJupyterCheckpoints(this.plugin);
  }
  onunload() {
    purgeJupyterCheckpoints(this.plugin);
  }
};

// src/jupyter-for-obsidian.ts
var JupyterForObsidian = class extends import_obsidian15.Plugin {
  constructor() {
    super(...arguments);
    /**
     * Responsible for storing settings in a reactive way.
     * Private to prevent overwriting of the instance.
     */
    this._settingsProxy = null;
    /**
     * Responsible for displaying the settings interface in Obsidian.
     * Private to prevent overwriting of the instance.
     */
    this._settingsTab = new JupyterSettingsTab5(this.app, this);
    /**
     * The Jupyter server (or environment) used by the plugin.
     */
    this.env = new JupyterEnvironment(
      this.app.vault.adapter.getBasePath(),
      DEFAULT_SETTINGS.debugConsole,
      DEFAULT_SETTINGS.pythonExecutable === "python" /* PYTHON */ ? "python" : DEFAULT_SETTINGS.pythonExecutablePath,
      DEFAULT_SETTINGS.jupyterTimeoutMs,
      DEFAULT_SETTINGS.jupyterEnvType,
      null,
      DEFAULT_SETTINGS.useSimpleMode
    );
    /** List of enabled features. Each feature acts as a "sub-plugin". */
    this.enabledFeatures = [];
  }
  /** Getter for the features to register for settings change events. */
  get settingsProxy() {
    return this._settingsProxy;
  }
  /** Getter for features to access and modify the settings. */
  get settings() {
    return this._settingsProxy.settings;
  }
  /** Getter for the settings tab to register settings into it. */
  get settingsTab() {
    return this._settingsTab;
  }
  /** Called by Obsidian when it loads the plugin. */
  async onload() {
    this._settingsProxy = new SettingsProxy(await this.loadSettings());
    this.settingsProxy.on("change", async (_key, _newVal, _oldVal) => {
      await this.saveSettings(this.settings);
    });
    this.enabledFeatures.push(
      new OpenNotebooksFeature(),
      new CreateNotebooksFeature(),
      new UpdateModalFeature(),
      new DeleteCheckpointsFeature()
    );
    this.addSettingTab(this.settingsTab);
    this.enabledFeatures.forEach(async (feature) => {
      await feature.onload(this);
    });
    this.app.workspace.on("quit", async (_tasks) => {
      this.onunload();
    });
    await this.env.endLoading();
  }
  /** Called by Obsidian when it unloads the plugin. */
  onunload() {
    this.env.exit();
    this.enabledFeatures.forEach((feature) => {
      var _a;
      (_a = feature.onunload) == null ? void 0 : _a.call(feature);
    });
  }
  /**
   * Gets the settings saved on the disk, merging them with default values
   * if needed, and returns the complete object.
   */
  async loadSettings() {
    return Object.assign(DEFAULT_SETTINGS, await this.loadData());
  }
  /**
   * Called by Obsidian whenever the persistent data file of the plugin
   * is modified externally (e.g., by another plugin or program).
   *
   * This implementation reloads the settings from the disk to ensure
   * the plugin is always in sync with the latest settings.
   *
   * It does so by setting the new values in the settings proxy,
   * ensuring events will be triggered for any changes.
   */
  async onExternalSettingsChange() {
    const settings = await this.loadSettings();
    for (const key in settings) {
      if (key in this.settings) {
        this.settings[key] = settings[key];
      }
    }
  }
  /** Writes the settings to the disk for persistence. */
  async saveSettings(settings) {
    await this.saveData(settings);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
